package main

import (
	"l1/21/adapter"
	"l1/21/client"
	"l1/21/macos"
	"l1/21/windows"
)

/*
Глобально этот паттерн проектирования стоит использовать в случае, если есть какая-то логика в разных классах не
подлежащая заключению в общий супер класс или есть потребность использовать какой-то "модуль" абстракция взаимодействия,
с которым отлична от других "модулей"
*/

/*
Принцип единой ответственности. Вы можете отделить код интерфейса или преобразования данных от основной
бизнес-логики программы.

Принцип открытости/закрытости. Вы можете добавлять в программу новые типы адаптеров, не нарушая существующий
клиентский код, при условии, что они работают с адаптерами через клиентский интерфейс.

С другой стороны
Общая сложность кода возрастает, поскольку необходимо ввести набор новых интерфейсов и классов.
Иногда проще просто изменить класс сервиса, чтобы он соответствовал остальному коду.
*/

/*
Пример с просторов интернета для конвертации полученных данных с сервиса в формате XML для запроса в другой тех же
данных в формате JSON

В проекте https://github.com/weebatt/CompetitionLogger в теории может понадобиться добавить второй обработчик логов
с гонки лыжников, где можно будет встроить его используя адаптер
*/

func main() {

	c := &client.Client{}
	m := &macos.Mac{}

	c.InsertLightningConnectorIntoComputer(m)

	windowsMachine := &windows.Windows{}
	windowsMachineAdapter := &adapter.WindowsAdapter{
		WindowMachine: windowsMachine,
	}

	c.InsertLightningConnectorIntoComputer(windowsMachineAdapter)
}
