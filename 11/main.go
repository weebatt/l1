package main

import (
	"fmt"
)

/*
Представленное решение работает за o(n)
Мне было не совсем понятно из ТЗ, что именно подразумевалось, а именно нужно было понимать под двумя слайсами
именно множество с неповторяющимися элементами, если так, то оптимально один из листов закинуть в мап и
пробегаться по второму проверяя наличие этого значения в мапе (в мапе элемент листа мы сохраняем как ключ), а
полученное пересечение сохранять в еще одну мапу, во избежание неоднозначности поведения в случае

list1 := []int{6, 2, 3}
list2 := []int{2, 3, 6, 4, 3}

при сохранении в лист даст 2, 6, 3

list1 := []int{6, 2, 3, 4, 3}
list2 := []int{2, 3, 6}

при сохранении в лист даст 2, 6, 3, 3

можно написать решение за o(n*log(n)) где на каждой итерации цикла по одному из массивов делать бин поиск
*/

func main() {
	list1 := []int{6, 2, 3}
	list2 := []int{2, 3, 6, 4, 3}

	cmap := PutListToMap(list1)

	intersectionOfLists := make(map[int]int)

	for _, v := range list2 {
		val, ok := cmap[v]
		if ok {
			intersectionOfLists[val] = v
		}
	}

	fmt.Println(intersectionOfLists)
}

func PutListToMap(list []int) map[int]int {
	rmap := make(map[int]int)
	for i := 0; i < len(list); i++ {
		rmap[list[i]] = i
	}
	return rmap
}
